name: "App Build & Release"

on:
  # Triggers the workflow on push events
  push:
    branches: [ "main", "master" ]
    tags: [ 'v*' ] # Also triggers on any tag starting with 'v'
    
  # Triggers the workflow on pull request events
  pull_request:
    branches: [ "main", "master" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

permissions:
  contents: write # Needed to create a release

jobs:
  # --- JOB 1: BUILD ALL BINARIES ---
  # This job "fans out" to build on all 3 OSs in parallel.
  # Binaries are only fully built and uploaded on a tag.
  
  build-binaries:
    name: Build Binaries
    # Use a matrix to run on all 3 platforms
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: macos-latest
            artifact_name: App-macOS
            asset_path: dist/package/*.dmg
            asset_name: app-macos.dmg
          - os: ubuntu-latest
            artifact_name: App-Linux
            asset_path: dist/package/*.AppImage
            asset_name: app-linux.AppImage
          - os: windows-latest
            artifact_name: App-Windows
            asset_path: dist/package/*.exe
            asset_name: app-windows.exe

    steps:
      # --- 1. Set up the environment ---
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
          cache: 'yarn'
      - name: "Install dependencies"
        run: yarn install --frozen-lockfile

      # --- 2. Verify Build (on main/PR) ---
      # This step runs for all triggers EXCEPT tags.
      - name: "Verify Build (on main/PR)"
        if: github.ref_type != 'tag'
        run: yarn verify # Assumes 'verify' is a lighter build/lint script
          
      # --- 3. Build and Package (on tag) ---
      # This step ONLY runs on a tag push.
      - name: "Build and Package for Release (on tag)"
        if: github.ref_type == 'tag'
        run: yarn build
        env:
          # GITHUB_TOKEN is required by electron-builder to publish
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # --- 4. Upload Artifact (on tag) ---
      # This step ONLY runs on a tag push.
      # It uploads the binary to be used by the 'create-release' job.
      - name: "Upload Release Artifact"
        if: github.ref_type == 'tag'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.asset_path }}
          if-no-files-found: error
          # We also store the final asset name for the release job
          # This is a bit of a workaround to pass the name
          retention-days: 1 
          
  # --- JOB 2: CREATE THE RELEASE ---
  # This job "fans in" after all builds are complete.
  # It only runs on a tag push.
  
  create-release:
    name: "Create GitHub Release"
    if: github.ref_type == 'tag'
    needs: [build-binaries] # Waits for all 3 builds to finish
    runs-on: ubuntu-latest
    
    steps:
      # --- 1. Download all artifacts ---
      - name: "Download all artifacts"
        uses: actions/download-artifact@v4
        with:
          path: artifacts # Download all artifacts to an 'artifacts' directory
          
      # --- 2. Create GitHub Release ---
      - name: "Create GitHub Release"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Trigger was a tag push. Creating release for ${{ github.ref_name }}..."
          
          # Find all downloaded assets.
          # This is more robust than hardcoding paths.
          ASSET_PATHS=()
          while IFS= read -r file; do
              ASSET_PATHS+=("$file")
          done < <(find artifacts -type f \( -name "*.dmg" -o -name "*.exe" -o -name "*.AppImage" \))
          
          if [ ${#ASSET_PATHS[@]} -eq 0 ]; then
            echo "::error::No build assets found in 'artifacts' directory."
            exit 1
          fi
          
          echo "Found assets to upload:"
          printf " - %s\n" "${ASSET_PATHS[@]}"
          
          # Use the GitHub CLI to create the release, attaching all found assets
          gh release create ${{ github.ref_name }} \
            "${ASSET_PATHS[@]}" \
            --title "Release ${{ github.ref_name }}" \
            --generate-notes